from rdflib import Graph, Namespace, RDFS, RDF, OWL, XSD, URIRef

def matching(concept_list_1, original_concept_list_1, concept_list_2, original_concept_list_2, matcher, similarity_threshold=0.6, save_path=None):
    """
    Ontology matching is the first step of ontology integration.
    We provide two types of matchers: 1. wordNet based matcher 2. LLM based matcher (see in matcher)
    :param concept_list_1: The concept list of main ontology, where there is no prefix
    :param original_concept_list_1: The concept list of associated ontology, where there is no prefix
    :param concept_list_2: The concept list of main ontology, where the prefixes are kept
    :param original_concept_list_2:The concept list of associated ontology, where the prefixes are kept
    :param matcher: the matcher
    :param similarity_threshold: similarity threshold is used to control the consequence
    :param save_path: the file path to save the generated correspondences
    :return: a graph that contains the generated correspondences
    """
    g = Graph()
    for concept_1,original_concept_1 in zip(concept_list_1, original_concept_list_1):
        max_sim = 0.
        the_original_concept_2 = None
        for concept_2, original_concept_2 in zip(concept_list_2, original_concept_list_2):
            sim = 0.
            try:
                sim = matcher.sim(concept_1, concept_2)
            except:
                continue
            if max_sim < sim:
                max_sim = sim
                the_original_concept_2 = original_concept_2
        if max_sim > similarity_threshold:
            g.add((original_concept_1, OWL['equivalentClass'], the_original_concept_2))
            g.add((the_original_concept_2, OWL['equivalentClass'], original_concept_1))
    if save_path is not None:
        g.serialize(save_path, format='ttl')
    return g


def conflict_detect(co_g: Graph, brick_g: Graph, PREFIX):
    '''
    The conflict_detect is to properly merge two ontologies. There are conflicts in the ontology matching.
    This process is firstly to find such conflicts
    :param co_g: the graph of correspondence generated by ontology matching
    :param brick_g: the graph of brick
    :param PREFIX: the settings of prefix
    '''
    detect_query = '''
        select ?a ?b where { ?a owl:equivalentClass ?b . }
        '''
    detect_res = co_g.query(detect_query)
    cor_dict = {}
    for class_a, class_b in detect_res:
        cor_dict[str(class_b)] = []
    for class_a, class_b in detect_res:
        cor_dict[str(class_b)].append(str(class_a))

    for key, value in cor_dict.items():
        if len(value) > 1:
            parents_list = []
            idx_list = []
            for term in value:
                try:
                    parents = []
                    prefix, concept = term.split('#')
                    # print(prefix, concept)
                    detect_query = '''select ?c where { %s rdfs:subClassOf* ?c .}''' % (
                                PREFIX[prefix] + ':' + concept)
                    temp_res = brick_g.query(detect_query)
                    for t in temp_res:
                        parents.append(str(t[0]))
                    parents_list.append(parents)
                    idx_list.append(term)
                except:
                    pass
            for parents in parents_list:
                idx_1 = parents_list.index(parents)
                parents_list_copy = parents_list.copy()
                parents_list_copy.remove(parents)
                for p in parents:
                    try:
                        prefix, concept = p.split('#')
                        detect_query = '''select ?s where { %s owl:disjointWith ?s .} '''%(PREFIX[prefix]+':'+concept)
                        temp_res = brick_g.query(detect_query)
                        if temp_res is not None:
                            for t in temp_res:
                                # print(parents_list_copy)
                                for parents_ in parents_list_copy:
                                    for p_ in parents_:
                                        if t[0] in p_:
                                            idx_2 = parents_list_copy.index(parents_)
                                            print("For ", key,  idx_list[idx_1], "conflict with", idx_list[idx_2])
                    except:
                        print(p,'has been passed')

def repair(onto_g_1, onto_g_2, co_g, PREFIX):
    range_query = '''select ?o where {?s rdfs:range ?o .}'''
    domain_query = '''select ?o where {?s rdfs:domain ?o .}'''

    res_1 = onto_g_1.query(domain_query)
    res_2 = onto_g_2.query(domain_query)

    for t in res_1:
        try:
            prefix, concept = t[0].split('#')

            query = '''select ?s where { ?s rdfs:subClassOf* %s}''' % (PREFIX[prefix] + ':' + concept)
            res_brick = onto_g_1.query(query)
            for s in res_brick:
                if (s[0], None, None) in co_g:
                    prefix, concept = s[0].split('#')
                    query = '''select ?s where { ?s owl:equivalentClass %s}''' % (PREFIX[prefix] + ':' + concept)
                    res_3 = co_g.query(query)
                    for m in res_3:
                        for t2 in res_2:
                            print(t2[0])
                            prefix, concept = t2[0].split('#')
                            query = '''select ?s where { ?s rdfs:subClassOf* %s}''' % (PREFIX[prefix] + ':' + concept)
                            res_p = onto_g_2.query(query)
                            res_p_list = []
                            for s2 in res_p:
                                res_p_list.append(s2[0])
                            # print(res_p_list)
                            if m[0] in res_p_list:
                                print(m[0], "shares conflict relation")
                            else:
                                print(t2[0],"has no relation share with others", )
        except:
            pass
